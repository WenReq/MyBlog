---
title: 02. 阿里前端p7面试题
lang: zh-CN
---

- V8 垃圾回收机制？
- 聊聊 reduce 原理，追问：手写 reduce
- weakmap 原理
- 浏览器工作原理
- 处理过内存泄露问题吗？
- 聊聊渲染合成层？
- 白屏的原因是什么？
- RAIL 知道吗？
- 如何极致的优化动画性能
- 为什么要写脚手架，带来的哪些价值？追问：我觉得你刚刚说的主流脚手架，可以满足你的需求
- react 的 diff和vue 的 diff 有什么区别？
- react.memo 适合用在什么场景下？
- react fiber 的发展演进？
- 知道进程调度策略吗？
- 聊聊常见的设计模式，追问：你在实际的工作中有用过吗？
- 如果团队的人不服你，你会怎么处理？
- 团队成员线上出现p0级 bug，你会怎么处理
- 你觉得你最擅长什么？
- 在你管理生涯中，你收获最大的是什么，哪些问题是你觉得棘手的问题？

## 1、V8 垃圾回收机制？

V8 引擎中的垃圾回收机制**负责**自动管理内存的分配和释放，以确保程序运行期间不会出现内存泄漏或垃圾堆积的问题。

JavaScript 自己内部会定时通过 GC(Garbage Collection) 进行垃圾回收。

### 垃圾回收策略 - 标记清除(Mark-Sweep)

在代码执行阶段，为程序中所有的变量添加上一个二进制字符（二进制运算最快）并初始值值为 0（默认全是垃圾），然后遍历所有的对象，**被使用的变量**标记值为 1，在程序运行结束时回收掉所有标记为 0 的变量，回收结束之后将现存变量标记统一值为 0，等待下一轮回收开启。

- 优点：标记清除算法思路清晰，实现比较交单。
- 缺点：由于系统分配的内存时间不同，回收的先后顺序也是不同的，这是就会导致**剩余空闲空间并不是连续的**，出现了**内存碎片**现象。会导致分配时间较长和控件浪费。

**标记整理**（Mark-Compact）算法闪亮登场，他的清除逻辑和标记清除算法基本相似，不过进行了优化，会在清除结束之后**将活着的空间进行整理向一端移动，同时清理掉内存的边界**。

### 垃圾回收策略 - 引用计数

跟踪记录每个变量被使用的次数，如果一个引用类型的值给声明的变量赋值，则将这个引用类型的引用次数为 1，如果同一个值被赋值给另一个变量，则引用计数再加 1，如果之前被赋值的变量值变成了其他引用类型，则原来的引用类型引入计数减 1，如果这个引用类型的引用计数为 0 表示，此时为不可达状态，浏览器垃圾回收器就将此类型占用的空间进行回收掉。

- 优点：1、实时回收，引用计数当归零就立即进行回收操作。2、不会暂停执行栈。
- 缺点：1、空间浪费。2、无法解决循环引用，无法回收。

### V8 对 GC 的优化

新生代和老生代的优化策略。将内存空间划分为新生代和老生代两个部分，不同部分执行不同的回收策略。

#### 新生代

存活时间较短的对象，只支持 1 ~ 8 M 的容量。使用区和空闲区。

#### 老生代

存放一些声明周期比较长，经过多次新生代回收还存在的对象，存储空间也比新生代大的多。使用的就是标记清除+标记整理。

## 2、聊聊 reduce 原理，追问：手写 reduce

对数组中的元素进行累计操作。它接收一个回调函数作为参数，该回调函数可以有四个参数：**累计值**（初始值或上一次回调的返回值）、**当前元素**、**当前索引**和**原数组**。 reduce 函数会依次遍历数组的每个元素，将回调函数的返回值作为下一次调用的累计值，最终返回一个累计值。

```js
Array.prototype.myReduce = function(callback, initialValue) {
  let accumulator = initialValue === undefined ? undefined : initialValue;
  for (let i = 0; i < this.length; i++) {
    if (accumulator === undefined) {
      accumulator = this[i];
    } else {
      accumulator = callback(accumulator, this[i], i, this);
    }
  }
  return accumulator;
}
```

## 3、Weakmap 原理

**键值对的存储方式**，与普通的 Map 对象不同，WeakMap 的键只能是对象，并且对于不再被引用的键，其对应的值会被自动回收，不会造成内存泄露。

WeakMap 的主要应用场景是在需要存储一些**临时数据**或**私有数据**，并且不希望影响垃圾回收的情况下使用。

1. 只接受对象作为键。
2. 弱引用特性。
3. 不可迭代
4. 没有公开的方法和属性。只能通过 `set()`、`get()` 和 `delete()` 方法来操作键值对。

## 4、浏览器工作原理

1. **用户输入 URL**：用户在浏览器输入 URL 或点击链接，触发浏览器的导航行为。
2. **发送 HTTP 请求**：浏览器向服务器发送 HTTP 请求，请求获取网页的资源，包括 HTML、CSS、JavaScript 文件以及其他相关的资源文件。
3. **接收和解析响应**：浏览器接收到服务器返回的 HTTP 响应，根据响应的内容类型进行解析。如果是 HTML 文件，则开始构建 DOM 树，同时解析 CSS 文件构建 CSSOM 树。如果有 JavaScript 文件，则执行 JavaScript 代码。
4. **构建渲染树**：浏览器将解析得到的  DOM 树和 CSSOM 树进行合并，构建出渲染树（Render Tree）。渲染树只包含需要显示的节点和样式信息。
5. **布局和绘制**：浏览器根据渲染树进行布局（Layout）和绘制（Painting）。布局阶段确定每个节点在屏幕上的位置和大小，绘制阶段将渲染树转换为屏幕上的像素。
6. **显示页面**：浏览器将绘制得到的像素信息发送到显示器，显示页面内容在用户的屏幕上。
7. **处理用户交互**：浏览器监听用户的交互事件，例如鼠标点击、滚动等，根据事件执行相应的操作。这可能包括重新构建渲染树、重新布局和绘制。
8. **定时器和异步任务**：浏览器执行定时器任务和处理异步任务，例如延迟执行的 JavaScript 代码、网络请求。

整个过程中，浏览器会不断地与服务器进行通信，下载和加载页面所需的资源，并将这些资源解析和渲染成用户可见的页面。同时，浏览器还负责处理用户的交互操作，并执行 JavaScript 代码来实现网页的动态效果和交互功能。

## 4、处理过内存泄露问题吗？

内存泄漏是指不再需要的对象或数据没有被正确释放，导致未使用的内存随时间累积。这可能导致应用程序性能下降，并可能导致崩溃。

1. **确定问题来源**：首先要确定内存泄漏的来源。这可以通过分析代码并使用调试工具和内存分析器来跟踪对象引用和内存使用情况来完成。
2. **审查对象声明周期**：审查代码中对象的声明周期，并**确保对象在适当的时候被创建和释放**。确保在不再需要时释放资源，比如关闭数据库连接或移除事件监听器。
3. **避免循环引用**：循环引用会阻止对象被垃圾回收。确保对象不会不必要的互相引入，或者使用弱引用来打破循环依赖。
4. **释放不再使用的对象**：明确地释放不再需要的对象或资源。这可以包括将引用置为null或调用特定的清理方法来释放资源。
5. **优化内存使用**：分析内存使用模式，并优化数据结构或算法以减少内存消耗。
6. **使用内存分析工具**：利用内存分析工具来分析内存使用情况并找出潜在的泄漏。这些工具可以提供关于内存分配、对象生命周期的信息，并识别内存使用过多的区域。
7. **测试和监控**：定期对应用程序进行测试，并监控其内存使用情况。这有助于识别潜在的内存泄漏，并确保修复措施的有效性。

## 5、聊聊渲染合成层

用于优化页面的渲染性能和动画效果。它是浏览器渲染引擎的一部分，用于将页面元素分成多层，并将这些层按照正确的顺序进行合成，以最终呈现在屏幕上。

1. 分层渲染：将页面元素分成多个独立的层。每个层都可以**单独进行绘制和处理**，这样可以减少不必要的重绘和重排操作。
2. 硬件加速：将**图形处理器（GPU）用于合成和渲染操作**。这可以提高渲染性能。
3. 层的创建：具有特定属性或样式的元素，例如 `position: fixed`、`opacity`、`transform` 等，通常会被提升为独立的层。
4. 合成过程：层的叠加、透明度混合、裁剪等操作，最终生成图像输出。
5. 优化渲染性能：渲染合成层可以减少页面的重绘和重排，从而提高渲染性能。只有发生变化的层才需要重新绘制，其他层可以保持不变，减少不必要的工作量。
6. 动画和滚动优化。

## 6、白屏的原因是什么？

1. 加载问题：服务器故障、网络连接问题或资源路径错误等。
2. 脚本错误：语法错误、逻辑错误或依赖项加载失败等问题引起的。
3. 样式问题：CSS文件路径错误、语法错误或样式冲突等问题引起的。
4. 渲染问题：浏览器版本问题、渲染引擎错误或不受支持的特性使用等原因引起的。
5. 编码问题：网页的字符编码可能与浏览器解析不一致，导致页面无法正常显示内容而呈现空白。
6. 其他问题：其他因素如服务器配置错误、缓存问题、安全策略限制等也可能导致白屏问题的发生。

## 7、RAIL 知道吗？

RAIL 是一个关于浏览器性能优化的**指导原则和方法论**。用系统化的方法评估和改善网页应用的性能。

RAIL 模型的核心理念是将用户的交互操作分解为四个关键阶段：

1. **响应（Response）**：在100毫秒以内响应用户的输入，使用户感觉到立即的反馈。这包括处理点击、滚动和触摸等用户交互。
2. **动画（Animation）**：保持动画流畅并以每秒60帧的速度进行渲染，以确保动画的平滑度和视觉连续性。
3. **空闲（Idle）**：利用主线程空闲时间执行后台任务，例如预加载资源、数据获取和计算等，以避免阻塞用户交互。
4. **加载（Load）**：在5秒内将页面内容加载完毕，并在此期间提供关键内容，以使用户能够尽快与页面进行交互。

## 8、如何极致的优化动画性能

1. **CSS 动画**：使用 `transform` 和 `opacity` 属性，避免使用 top、left 等属性进行动画操作。
2. **requestAnimationFrame**：浏览器提供的优化动画的方法，更好地与浏览器的渲染机制同步。
3. **减少重绘和回流**：通过合并多个 DOM 修改、使用 `transform` 进行动画变换，避免频繁的 DOM 重绘和回流操作，以提高性能。
4. **使用硬件加速**：使用 CSS 属性 `translate3d`、`scale3d` 等可以启用 GPU 硬件加速，提高动画的性能。
5. **避免使用阻塞操作**：确保动画执行期间没有长时间的 JavaScript 计算或网络请求阻塞主线程。

## 9、为什么要写脚手架，带来了哪些价值？

1. 提高开发效率
2. 统一项目结构和规范
3. 提供常用的功能和工具集成
4. 简化部署和发布

## 10、react 的 diff 和 vue 的 diff 的区别

- React 的 diff 算法采用的是基于**双指针**的算法，称为 "React Reconciliation"。它通过比较两个虚拟 DOM 树的差异来确定需要更新的部分，并最小化对实际 DOM 的操作。
- Vue 的 diff 算法采用的是基于**双端队列**的算法，称为 "Vue diff"。它通过对新旧虚拟 DOM 树进行**同层比较**，找到最小的差异集合，并在实际 DOM 中进行相应的更新。

## 11、react.memo 适合用在什么场景下？

优化组件的渲染性能，React.memo 可以用于包裹函数组件，用于**对组件进行浅层的 Props 比较**，如果前后 props 没有变化，则会使用缓存的组件渲染结果。

React.memo 适合用在一下场景中：

1. 当组件的**渲染开销较大**，但组件的 props 没有变化时，可以使用 React.memo 进行性能优化，避免不必要的重新渲染。
2. 当组件的 Props 是通过父组件传递的，而父组件的渲染频率较高，但子组件 props 并不频繁变化时，可以使用 ReacT.memo 来避免子组件的重复渲染。

## 12、react fiber 的发展演进

1. React 15及之前版本：使用了基于栈的调和算法，称为“stack reconciler”。这种调和算法在处理大型组件树或复杂交互时容易出现性能问题，导致用户界面的卡顿和响应性差。
2. React 16及引入Fiber：这是一个**全新的调和算法和渲染引擎**。Fiber 的目标是实现**增量渲染**和**可中断**的渲染，以提高React应用的响应性和渲染性能。
3. **引入异步渲染**：**将渲染任务分解为多个优先级不同的子任务**，使得React可以更好地响应用户输入，并在空闲时间执行优先级较低的任务。
4. **优先级调度和任务切片**
5. **错误边界**：更好地处理运行时错误，避免整个应用崩溃，并提供优雅的错误处理和回退机制。
6. **生命周期重构**：引入了新的生命周期方法，并提供了更细粒度的控制和更好的性能优化。

它通过引入异步渲染、优先级调度、任务切片和错误边界等特性，提升了React应用的响应性能和用户体验，并为未来的功能和扩展提供了更强的基础。

## 13、知道进程调度策略吗？

负责决定在多个进程之间如何分配 CPU 的使用权，以实现公平性、效率和响应性。

下面是几种常见的进程调度策略：

1. **先来先服务（FCFS）**：按照**进程到达的顺序**分配 CPU 时间片，先到达的进程先执行。
2. **短作业优先（SJF）**：选择估计执行时间最短的进程。这种策略能够最大程度地减少平均等待时间，但可能会导致长作业饥饿的问题。
3. **优先级调度**：为每个进程分配一个优先级，CPU优先执行优先级最高的进程。但可能导致低优先级进程长时间等待。
4. **时间片轮转（Round Robin）**：将CPU时间划分为固定大小的时间片，每个进程按顺序执行一个时间片，然后切换到下一个进程。这种策略可以实现公平性和响应性，但可能导致上下文切换开销过大。
5. **多级反馈队列调度**：将进程分为多个优先级队列，每个队列具有不同的时间片大小。进程开始时进入最高优先级队列，如果用完时间片仍未执行完，则降低优先级并进入下一个队列。这种策略结合了短作业优先和时间片轮转的优点，既考虑了短作业的优先执行，又保证了长作业的执行机会。

## 14、聊聊常见的设计模式，追问：你在实际工作中有用过吗？

1. 单例模式：确保一个类只有一个实例，并提供全局访问点。（`new Vue()`）
2. 工厂模式：通过一个工厂类创建对象，隐藏对象的创建细节。
3. 观察者模式：定义一种一对多的依赖关系，当一个对象的状态发生改变时，其他依赖者将收到通知。（vue 的响应式系统）
4. 适配器模式：将一个类的接口转换成客户端所期望的接口。
5. 策略模式：定义一系列的算法，将它们封装起来，并使它们可以相互替换。
6. 装饰器模式：动态地给对象添加额外的职责，是继承的一种替代方案。
7. MVC 模式：将应用程序分为模型、视图和控制器三个部分，实现关注点分离。
8. 迭代器模式：提供一种顺序访问聚合对象中各个元素的方法，而无需暴露其内部表示。

## 15、如果团队的人不服你，你会怎么处理？

1. 倾听和理解：确保每个人都有机会表达自己的意见和观点。。
2. 解决冲突：找到双方都可以接受的共同点和妥协方案。。
3. 透明和开放：团队成员分享决策背后的原因和依据，以便让他们了解决策的合理性和目标。。
4. 激励和赋能：理解自己的价值和贡献。
5. 持续改进：积极寻求反馈和建议，不断改进我的领导方式和团队管理策略。

## 16、团队成员线上出现p0级 bug，你会怎么处理

1. 紧急响应。
2. 集中资源。
3. 确定根本原因。
4. 实施临时修复。
5. 持续沟通。
6. 彻底解决问题。
7. 审查和总结经验。

