---
title: 1. JS 基础知识点及常考面试题（一）
lang: zh-CN
---

## 类型

JS 数据类型分为两大类：

1. 原始类型
2. 对象类型

### 原始（Primitive）类型

在 JS 中，存在着 7 种原始值，分别是：

- `boolean`
- `null`
- `undefined`
- `number`
- `string`
- `symbol`
- `bigint`

首先原始类型存储的都是值，是**没有函数可以调用**的，比如 `undefined.toString()`。

此时你肯定会有疑问，这不对呀，明明 `'1'.toString()` 是可以使用的。其实在这种情况下，`'1'` 已经不是原始类型了，而是**被强制转换**成了 `String` 类型也就是对象类型，所以可以调用 `toString` 函数。

JS 的 `number` 类型是浮点类型的，在使用中会遇到某些 Bug，比如 `0.1 + 0.2 !== 0.3`。

虽然 `typeof null` 会输出 `object`，但是这只是 JS 存在的一个悠久 Bug。在 JS 的最初版本中使用的是 32 位系统，为了性能考虑使用低位存储变量的类型信息，`000` 开头代表是对象，然而 `null` 表示为全零，所以将它错误的判断为 `object` 。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。

### 对象（Object）类型

对象类型和原始类型不同的是，原始类型存储的是值，一般存储在**栈**上，对象类型存储的是**地址**（指针），数据存储在**堆**上。

当创建了一个对象类型的时候，计算机会在堆内存中帮我们开辟一个空间来存放值，但是我们需要找到这个空间，这个空间会拥有一个地址（指针）。

### 涉及面试题

- `0.1 + 0.2 !== 0.3`
- JS 类型有哪些？
- 大数相加、相乘算法题
- 修改对象得出结果笔试题

## 类型判断

类型判断有多种方式。

### typeof

`typeof` 对于原始类型来说，除了 `null` 都可以显示正确的类型，如果你想判断 `null` 的话可以使用 `variable === null`。

`typeof` 对于对象来说，除了函数都会显示 `object`，所以说 `typeof` 并不能准确判断变量到底是什么类型。

### instanceof

`instanceof` 通过原型链的方式来判断是否为构造函数的实例，常用于判断具体的对象类型。

另外其实我们还可以直接通过构建函数来判断类型：

```js
// true
[].constructor === Array;
```

### Object.prototype.toString.call

```javascript
Object.prototype.toString.call(null); // "[Object Null]"
```

### isXXX API

```js
Array.isArray([]); // true
isNaN(","); // true
Number.isNaN(NaN); // true
```

### 常见面试题

- JS 类型如何判断，有哪几种方式可用
- `instanceof` 原理
- 手写 `instanceof`

## 类型转换

首先我们要知道，在 JS 中类型转换只有三种情况，分别是：

- 转换为**布尔值**
- 转换为**数字**
- 转换为**字符串**

转布尔值

- `number` 除了 0、-0、NaN 都为 true
- `string` 除了空串都为 true
- `undefined、null` false
- `引用类型` true

转字符串

- `number` 5 => '5'
- `Boolean、函数、Symbol` 'true'
- `数组` [1, 2] => '1, 2'
- `对象` '[object Object]'

转数字

- `string` '1' => 1，'a' => NaN
- `数组` 空数组为 0，存在一个元素且为数字转数字，其他情况 NaN
- `null` 0
- `除了数组的引用类型` NaN
- `Symbol` 报错

### 转 Boolean

在条件判断时，除了 `undefined`， `null`， `false`， `NaN`， `''`，`0`， `-0`，其他所有值都转为 `true`，包括所有对象。

### 对象转原始类型

对象在转换类型的时候，会调用内置的 `[[ToPrimitive]]` 函数，对于该函数来说，算法逻辑一般来说如下：

- 如果已经是原始类型了，那就不需要转换了。
- 如果需要转**字符串类型**就调用 `x.toString()`，转换为基础类型的话就返回转换的值。**不是字符串类型**的话就先调用 `valueOf`，结果不是基础类型的话再调用 `toString`。
- 调用 `x.valueOf()`，如果转换为基础类型，就返回转换的值
- 如果都没有返回原始值，就会报错

当然你也可以重写 `Symbol.toPrimitive` ，该方法在转原始类型时调用优先级最高。

### 四则运算符

加法运算符不同于其他几个运算符，它有以下几个特点：

- 运算中其中一方为字符串，那么就会把另一方也转换为字符串
- 如果一方不是字符串或者数字，那么会将它转换为数字或字符串

```js
1 + "1"; // '11'
true + true; // 2
4 + [1, 2, 3]; // '41,2,3'
```

如果你对于答案有疑问的话，请看解析：

- 对于第一行代码来说，触发特点一，所以将数字 `1` 转换为字符串，得到结果 `'11'`
- 对于第二行代码来说，触发特点二，所以将 `true` 转为数字 `1`
- 对于第三行代码来说，触发特点二，所以将数组通过 `toString` 转为字符串 `1,2,3`，得到结果 `41,2,3`

另外对于加法还需要注意这个表达式 `'a' + + 'b'`

```javascript
"a" + +"b"; // "aNaN"
```

因为 `+ 'b'` 等于 NaN，所以结果为 `"aNaN"`，你可能也会在一些代码中看到过 `+ '1'` 的形式来快速获取 `number` 的类型。

那么对于**除了加法**的运算符来说，**只要其中一方是数字，那么另一方就会被转为数字**

```js
4 * "3"; // 12
4 * []; // 0
4 * [1, 2]; // NaN
```

### 比较运算符

1. 如果是对象，就通过 `toPrimitive` 转换对象
2. 如果是字符串，就通过 `unicode` 字符索引来比较

```js
let a = {
  valueOf() {
    return 0;
  },
  toString() {
    return "1";
  },
};

a > -1; // true
```

在以上代码中，因为 `a` 是对象，所以会通过 `valueOf` 转换为原始类型再比较值。

### 常见面试题

其实类型转换的题目基本只会出现在笔试题中，比较多变，只能硬背规则。

## this

- 纯函数调用 `this` 指向 `window`
- 对象中的函数，谁调用就指向谁，指向对象
- `new` 创建的构造函数指向创建的这个对象
- `bind` 改变上下文的 API，对于这些函数来说，`this` 取决于第一个参数，如果第一个参数为空，那么就是 `window`。(不管我们给函数 `bind` 几次，`fn` 中的 `this` 永远由第一次 `bind` 决定。)

箭头函数时没有 `this` 的，箭头函数中的 `this` 只取决包裹箭头的第一个普通函数的 `this`。

以上就是 `this` 的所有规则了。实际中可能会发生多个规则同时出现的情况，这时候不同的规则之间会根据优先级最高的来决定 `this` 最终指向哪里。

首先，`new` 的方式优先级最高，接下来是 `bind` 这些函数，然后是 `obj.foo()` 这种调用方式，最后是 `foo` 这种调用方式，同时，箭头函数的 `this` 一旦被绑定，就不会再被任何方式所改变

### 常见面试题

```javascript
const a = {
  b: 2,
  foo: function () {
    console.log(this.b);
  },
};

function b(foo) {
  // 输出什么？
  foo();
}

b(a.foo);
```
